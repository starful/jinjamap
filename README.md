# â›©ï¸ JinjaMap - Your Interactive Guide to Japan's Sacred Power Spots

An interactive web application designed to help travelers discover and explore Japan's rich spiritual heritage. Find your fortune by filtering shrines based on themes like Wealth, Love, and Success.

ğŸ”— **Live Demo:** [https://jinjamap.com](https://jinjamap.com)



---

## âœ¨ Features

*   **Interactive Google Map**: Shrines are plotted on a dynamic map. The initial view automatically adjusts to show all available locations.
*   **Theme-based Filtering**: Easily find shrines that match your wishes (e.g., Wealth, Love, Health, Success).
*   **Detailed Shrine Guides**: Each shrine has its own dedicated page with history, details, access information, and nearby onsen recommendations.
*   **Fully Automated Content Pipeline**: New shrine articles are generated by AI, leveraging a sophisticated, automated workflow.
*   **Intelligent Image Optimization**: A custom script automatically compresses new images to a target file size, ensuring fast load times without sacrificing quality.
*   **Mobile-Responsive Design**: A seamless experience whether you're on a desktop or on the go.
*   **Omikuji Fortune Game**: A fun, interactive feature to draw a daily fortune slip and get a recommendation for a lucky shrine.

---

## ğŸ› ï¸ Tech Stack & Architecture

This project leverages a modern, efficient stack designed for performance and ease of maintenance.

*   **Backend**: Python 3.10, Flask
*   **Frontend**: Vanilla JavaScript (ESM), HTML5, CSS3, Google Maps API
*   **Data & Content**: Markdown with YAML Frontmatter for all shrine data.
*   **Automation & CI/CD**:
    *   **Python Scripts**: For AI content generation (`jinja_generator.py`) and image optimization (`compress_images_target.py`).
    *   **AI**: Google Gemini API for article creation.
    *   **Containerization**: Docker
    *   **CI/CD Pipeline**: Google Cloud Build
*   **Deployment**: Google Cloud Run (Serverless)

---

## ğŸš€ The Content Pipeline: From Idea to Deployment

The project's core strength is its fully automated content workflow, which minimizes manual work and ensures consistency.

1.  **GENERATE**: `script/jinja_generator.py` uses a CSV list and the **Gemini API** to write new shrine articles in Markdown format.
2.  **OPTIMIZE**: New images are added and then processed by `compress_images_target.py`, which intelligently resizes and compresses them to under 100KB.
3.  **BUILD**: When changes are pushed to GitHub, **Cloud Build** triggers. It runs `build_data.py` inside the Docker container, compiling all Markdown files into a single, optimized `shrines_data.json`.
4.  **DEPLOY**: The newly built Docker image is pushed to the Artifact Registry and automatically deployed as a new version on **Cloud Run**.

---

## ğŸ“‚ Project Structure

```text
jinjaMap/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ content/                 # Shrine data (Markdown files)
â”‚   â”‚   â””â”€â”€ images/              # Shrine images
â”‚   â”œâ”€â”€ static/                  # Assets (CSS, JS, Images, pre-built JSON)
â”‚   â”œâ”€â”€ templates/               # HTML Templates
â”‚   â””â”€â”€ __init__.py              # Flask Application
â”‚
â”œâ”€â”€ script/
â”‚   â”œâ”€â”€ jinja_generator.py       # (Step 1) AI Content Generator
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ compress_images_target.py    # (Step 2) Image Optimization Script
â”œâ”€â”€ build_data.py                # (Step 3) Build Script (MD -> JSON)
â”œâ”€â”€ Dockerfile                   # Docker Configuration
â”œâ”€â”€ cloudbuild.yaml              # (Step 4) CI/CD Configuration
â””â”€â”€ requirements.txt             # Python Dependencies
```

---

## ğŸ“ Content Management & Workflow

Adding new content is simple and requires no database interaction.

#### Step 1: Generate New Articles

Run the AI content generator. It will automatically pick unprocessed shrines from the CSV list and generate new `.md` files in `app/content/`.

```bash
# Generates 5 new articles by default
python script/jinja_generator.py
```

#### Step 2: Add and Optimize Images

1.  Add high-resolution source images corresponding to the new articles into `app/content/images/`.
2.  Run the image optimization script. It will process only large images and save the optimized versions in the `compressed_images` folder.

```bash
python compress_images_target.py
```
3.  **Review the results** in the `compressed_images` folder. If satisfied, **replace the original images** in `app/content/images/` with these optimized versions.

#### Step 3: Commit and Push

Commit all the new Markdown files and optimized images to your Git repository.

```bash
git add .
git commit -m "Feat: Add 5 new shrine guides and optimized images"
git push origin main
```

Pushing to the `main` branch will automatically trigger the build and deployment process on Google Cloud.

---

## ğŸ“¦ Deployment

Deployment is fully automated via the `cloudbuild.yaml` configuration. Any push to the main branch triggers a new build and deployment to **Google Cloud Run**.

The process includes:
1.  Installing dependencies.
2.  Running `build_data.py` to generate `shrines_data.json`.
3.  Containerizing the app with Docker.
4.  Pushing the image to Google Artifact Registry.
5.  Deploying the new revision to Cloud Run.

---

## ğŸ›¡ï¸ License

This project is open-source and available under the [MIT License](LICENSE).